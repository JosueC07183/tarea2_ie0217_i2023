<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tarea 2 IE0217: Algoritmos/headerSort.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tarea 2 IE0217
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_aa80ac9afd027b22714a488f01045f86.html">Algoritmos</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">headerSort.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Headers del programa principal.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for headerSort.hpp:</div>
<div class="dyncontent">
<div class="center"><img src="headerSort_8hpp__incl.png" border="0" usemap="#aAlgoritmos_2headerSort_8hpp" alt=""/></div>
<map name="aAlgoritmos_2headerSort_8hpp" id="aAlgoritmos_2headerSort_8hpp">
<area shape="rect" title="Headers del programa principal." alt="" coords="38,5,234,32"/>
<area shape="rect" title=" " alt="" coords="5,80,72,107"/>
<area shape="rect" title=" " alt="" coords="96,80,176,107"/>
<area shape="rect" title=" " alt="" coords="200,80,285,107"/>
</map>
</div>
</div>
<p><a href="headerSort_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac25189db92959bff3c6c2adf4c34b50a"><td class="memItemLeft" align="right" valign="top"><a id="ac25189db92959bff3c6c2adf4c34b50a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DIM</b>&#160;&#160;&#160;7</td></tr>
<tr class="separator:ac25189db92959bff3c6c2adf4c34b50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9256ea7a1cd6b1791976f2092c47a17a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="headerSort_8hpp.html#a9256ea7a1cd6b1791976f2092c47a17a">BubbleSort</a> (int length, int arr[])</td></tr>
<tr class="memdesc:a9256ea7a1cd6b1791976f2092c47a17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acá se encuentran en el nombre de cada función.  <a href="headerSort_8hpp.html#a9256ea7a1cd6b1791976f2092c47a17a">More...</a><br /></td></tr>
<tr class="separator:a9256ea7a1cd6b1791976f2092c47a17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7affa5c09023b994962ba53a7452debf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="headerSort_8hpp.html#a7affa5c09023b994962ba53a7452debf">selectionSort</a> (int length, int arr[])</td></tr>
<tr class="memdesc:a7affa5c09023b994962ba53a7452debf"><td class="mdescLeft">&#160;</td><td class="mdescRight">La idea es seleccionar el elemento más pequeño y colocarlo correctamente. Esa es la función del ciclo for, ir comparando cada elemento y si es menor, lo desplaza a la izquierda, es decir, hace swap esto porque se tiene un condicional encargado de esto.  <a href="headerSort_8hpp.html#a7affa5c09023b994962ba53a7452debf">More...</a><br /></td></tr>
<tr class="separator:a7affa5c09023b994962ba53a7452debf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036f75dfdc2b04b1754853abbf82f09a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="headerSort_8hpp.html#a036f75dfdc2b04b1754853abbf82f09a">insertionSort</a> (int length, int arr[])</td></tr>
<tr class="memdesc:a036f75dfdc2b04b1754853abbf82f09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consta de dos ciclos for, el primero se encarga de reco- rrer la dimensión del array. Donde se usa la variable temp para almacenarlo. El segundo loop for se encarga de ir decrementando el recorrido de los elementos, y ahora la variable pos toma la posición del array actual. Luego, el ciclo while se ejecutará siempre que sea mayor a cero y la posición actual sea mayor al que esta en la variable pos.  <a href="headerSort_8hpp.html#a036f75dfdc2b04b1754853abbf82f09a">More...</a><br /></td></tr>
<tr class="separator:a036f75dfdc2b04b1754853abbf82f09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6deda3bd254bf5da0c533d0a02b81922"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="headerSort_8hpp.html#a6deda3bd254bf5da0c533d0a02b81922">quickSort</a> (int arr[], int low, int high)</td></tr>
<tr class="memdesc:a6deda3bd254bf5da0c533d0a02b81922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primeramente se define el pivote, haciendo el promedio del array. Luego, con el primer while, se ejecuta mientras i sea menor a j, entonces se toma el elemento menor al pivote y se incrementa. Pero el pivote tendrá elementos mayores a él, por eso se hacen a la derecha. Una vez que se han divido los elementos, resulta que estos no están acomod- ados pero gracias al swap es posible reordenarlos y el condicional toma el valor low(y el high) y lo compara, para usar la función quickSort, es decir, realizar toda el algoritmo de nuevo.  <a href="headerSort_8hpp.html#a6deda3bd254bf5da0c533d0a02b81922">More...</a><br /></td></tr>
<tr class="separator:a6deda3bd254bf5da0c533d0a02b81922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ae67f62e820a70e17ddb0c616cc08b"><td class="memItemLeft" align="right" valign="top"><a id="ab5ae67f62e820a70e17ddb0c616cc08b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_array</b> (int length, int arr[])</td></tr>
<tr class="separator:ab5ae67f62e820a70e17ddb0c616cc08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Headers del programa principal. </p>
<p>Licencia MIT</p>
<p>Copyright (c) [2023] Tarea 2 - Grupo 2 - IE 0217 - I Ciclo 2023</p>
<p>Se concede aquí, sin cargo, a cualquier persona que obtenga una copia de este software y los archivos de documentación asociados (el "Software"), para utilizar el Software sin restricciones, incluyendo, sin limitación, los derechos para usar, copiar, modificar, fusionar, publicar, distribuir, sublicenciar y/o vender copias del Software, y para permitir a las personas a quienes se les proporcione el Software que lo hagan, sujeto a las siguientes condiciones:</p>
<p>El aviso de copyright anterior y este aviso de permiso se incluirán en todas las copias o partes sustanciales del Software.</p>
<p>EL SOFTWARE SE PROPORCIONA "TAL CUAL", SIN GARANTÍA DE NINGÚN TIPO, EXPRESA O IMPLÍCITA, INCLUYENDO PERO NO LIMITADO A GARANTÍAS DE COMERCIALIZACIÓN, IDONEIDAD PARA UN PROPÓSITO PARTICULAR Y NO INFRACCIÓN. EN NINGÚN CASO LOS AUTORES O TITULARES DEL COPYRIGHT SERÁN RESPONSABLES POR NINGUNA RECLAMACIÓN, DAÑO O OTRA RESPONSABILIDAD, YA SEA EN UNA ACCIÓN CONTRACTUAL, AGRAVIO O DE OTRO MODO, QUE SURJA DE, FUERA DE O EN CONEXIÓN CON EL SOFTWARE O EL USO U OTROS ACUERDOS EN EL SOFTWARE.</p>
<dl class="section author"><dt>Author</dt><dd>JosuéSC </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.1 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2023-04-30</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2023 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9256ea7a1cd6b1791976f2092c47a17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9256ea7a1cd6b1791976f2092c47a17a">&#9670;&nbsp;</a></span>BubbleSort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BubbleSort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arr</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acá se encuentran en el nombre de cada función. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>esto es la longitud del array. </td></tr>
    <tr><td class="paramname">arr</td><td>array por default.</td></tr>
  </table>
  </dd>
</dl>
<p>Acá se encuentran en el nombre de cada función. </p>
<p>Se usa un ciclo for y un condicional para ir comparando cada elemento del arrray. Como el primer no tiene nadie con quién compararse al lado izquierdo solo se compara con el de la derecha. Pero, el segundo elemento se debe comparse con los dos números (izquierda y derecha) . Y así recursivamente hasta ordenarse, en cada iteración se hace swap de los números, dependiendo de si es mayor o menor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>identificador del bubbleSort. </td></tr>
    <tr><td class="paramname">temp</td><td>variable temporal a guardar.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a036f75dfdc2b04b1754853abbf82f09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036f75dfdc2b04b1754853abbf82f09a">&#9670;&nbsp;</a></span>insertionSort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insertionSort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arr</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consta de dos ciclos for, el primero se encarga de reco- rrer la dimensión del array. Donde se usa la variable temp para almacenarlo. El segundo loop for se encarga de ir decrementando el recorrido de los elementos, y ahora la variable pos toma la posición del array actual. Luego, el ciclo while se ejecutará siempre que sea mayor a cero y la posición actual sea mayor al que esta en la variable pos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>variable que guarda la posición actual del array. </td></tr>
    <tr><td class="paramname">temp</td><td>variable que almacena el array original. </td></tr>
    <tr><td class="paramname">j</td><td>contador que se decrementa conforme se recorre el array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6deda3bd254bf5da0c533d0a02b81922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6deda3bd254bf5da0c533d0a02b81922">&#9670;&nbsp;</a></span>quickSort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void quickSort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Primeramente se define el pivote, haciendo el promedio del array. Luego, con el primer while, se ejecuta mientras i sea menor a j, entonces se toma el elemento menor al pivote y se incrementa. Pero el pivote tendrá elementos mayores a él, por eso se hacen a la derecha. Una vez que se han divido los elementos, resulta que estos no están acomod- ados pero gracias al swap es posible reordenarlos y el condicional toma el valor low(y el high) y lo compara, para usar la función quickSort, es decir, realizar toda el algoritmo de nuevo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pivote</td><td>esta variable es la que se encarga de particionar el arreglo. </td></tr>
    <tr><td class="paramname">low</td><td>acá se guarda los elementos menores al pivote. </td></tr>
    <tr><td class="paramname">high</td><td>guarda los elementos mayores al pivote. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7affa5c09023b994962ba53a7452debf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7affa5c09023b994962ba53a7452debf">&#9670;&nbsp;</a></span>selectionSort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void selectionSort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arr</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>La idea es seleccionar el elemento más pequeño y colocarlo correctamente. Esa es la función del ciclo for, ir comparando cada elemento y si es menor, lo desplaza a la izquierda, es decir, hace swap esto porque se tiene un condicional encargado de esto. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_Min</td><td>este es el elemento pequeño que se encuentra en cada iteración. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
