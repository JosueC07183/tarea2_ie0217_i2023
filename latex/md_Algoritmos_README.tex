\hypertarget{md_Algoritmos_README_autotoc_md1}{}\doxysubsubsection{Escuela de Ingeniería Eléctrica}\label{md_Algoritmos_README_autotoc_md1}
\hypertarget{md_Algoritmos_README_autotoc_md2}{}\doxysubsubsection{Faculta de Ingeniería}\label{md_Algoritmos_README_autotoc_md2}
\hypertarget{md_Algoritmos_README_autotoc_md3}{}\doxysubsubsection{IE0217-\/\+Estructuras de Abstractas de Datos y Algoritmos}\label{md_Algoritmos_README_autotoc_md3}
\hypertarget{md_Algoritmos_README_autotoc_md4}{}\doxyparagraph{Profesor\+: Esteban Badilla}\label{md_Algoritmos_README_autotoc_md4}
\hypertarget{md_Algoritmos_README_autotoc_md5}{}\doxyparagraph{Estudiante\+: Josué Salmerón Córdoba}\label{md_Algoritmos_README_autotoc_md5}
\hypertarget{md_Algoritmos_README_autotoc_md6}{}\doxyparagraph{I ciclo 2023}\label{md_Algoritmos_README_autotoc_md6}
\hypertarget{md_Algoritmos_README_autotoc_md7}{}\doxysubsubsection{Tarea 2}\label{md_Algoritmos_README_autotoc_md7}
\hypertarget{md_Algoritmos_README_autotoc_md8}{}\doxysection{Resumen}\label{md_Algoritmos_README_autotoc_md8}
\begin{quote}
En esta tarea se aprovechó del prototipo de cada función o más bien de los prototipos de algoritmos de ordenamiento tales como Bubble\+Sort, inser\+Sort, selection\+Sort y quick\+Sort. A partir de esto se implementaron su lógica para observar la función que realizan (que al final de cuentas es lo mismo) sin embargo, se analizó la complejidad que tiene cada uno de estos algoritmos usando la notación Big O, de donde Bubble\+Sort posee más ventajas cuando trabaja un array pequeño. Mientras cuando se trabaja con un array grande, quick\+Sort es muy eficiente, pero siempre habrá una mejor para estos casos como lo es el caso de Merge\+Sort ya que posee una mejor estabilidad. \end{quote}
\hypertarget{md_Algoritmos_README_autotoc_md9}{}\doxysection{Análisis de la notación Big O en cada algoritmo de ordenamiento.}\label{md_Algoritmos_README_autotoc_md9}

\begin{DoxyItemize}
\item Bubble\+Sort\+: Este algoritmo tiene una complejidad temporal en el peor de los caso de O(n2). Su complejidad espacial es de O(1). Por lo que el número de swaps en él es igual al número de pares de inversión en la matriz dada. Cuando los elementos del array son pocos, el algoritmo es muy eficiente.
\item Selection\+Sort\+: posee un bajo rendimiento. Este algoritmo utiliza el método de selección y funciona en O(n$^\wedge$2) en el mejor, promedio y peor de los casos.
\item insertion\+Sort\+: Posee un rendimiento no tan bueno, usa el método de insercción que funciona a O(n) en el mejor de los casos. Por su parte, en el peor de los casos funciona a O(n$^\wedge$2).
\item quick\+Sort\+: su clasificación de comparación es inestable con un rendimiento mediocre. Quicksort utiliza el método de partición y puede funcionar, en el mejor de los casos y en promedio a\+: O(n log (n)). No obstante, puede funcionar en O(n$^\wedge$2) en el peor de los casos. Lo bueno de este algoritmo es que para arrays muy grandes es muy eficiente.
\end{DoxyItemize}\hypertarget{md_Algoritmos_README_autotoc_md10}{}\doxysection{Comandos para correr la tarea}\label{md_Algoritmos_README_autotoc_md10}

\begin{DoxyItemize}
\item Basta con abrir un terminal dentro de la carpeta {\ttfamily Algoritmos}y escribir el siguiente comando\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{make run}

\end{DoxyCode}

\end{DoxyItemize}\hypertarget{md_Algoritmos_README_autotoc_md11}{}\doxysection{Referencias.}\label{md_Algoritmos_README_autotoc_md11}
\begin{quote}
\href{https://big-o.io/}{\texttt{ Literatura consultada}} \end{quote}
